## Experiment 1 - Finding a Gröbner Basis

In order to find a Gröbner basis for the system of equations we tried several approaches. The following are some of the instances that we implemented.

- Taking advantage of the fact that the computation complexity of a Gröbner Basis has been computed with accuracy in the case of homogeneous polynomials, we homogenized the system by changing every $t_j$ with $t_j^2$ and removing the polynomial $p_0$. This does not change the solutions of the system, since the targets are expected to be positive numbers, and one can simply add $p_0$ to the basis once it is computed to add conditions on $x_0$. This in fact works for the cases where we could find a Gröbner basis, and adding the polynomial $p_0$ is fundamental to reduce the dimension of the problem, that is, to make it a system with a finite amount of solutions.
- Since in practice one can fix at least one variable, we tried $x_0=t_0=1$. Also, since this implies that $p_1=x_{n-1}-t_1$ and $p_2=x_{n-2}+x_1x_{n-1}-t_2$, one can easily replace $x_{n-1}=t_1$ and $x_{n-2}=t_2-t_1x_1$. This reduces the number of variables in $4$ and does not change the total degree of the system, which is extremely useful since the complexity of computing a Gröbner basis has been estimated to be double exponential in the number of variables with base being the total degree of the system.

In both cases, we used the implementations of Buchberger and F5 algorithms in the Python package `sympy`, however after running every combination in parallel in the High Performance Computing Cluster at the School of Engineering of UC for over a couple of months, just the cases with $n=2,3,4,5$ and $6$ have successfully finished. Moreover, the case $n=7$ seems to be using a huge amount of ram, implying that the Gröbner basis for such a case is extremely large and making its use in real-time non-viable in a compact environment.
