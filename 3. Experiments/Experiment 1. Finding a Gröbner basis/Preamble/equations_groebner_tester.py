from sympy import *
from functions import *

#n is the number of equations and hence n-1 is the number of harmonics of the ghostly sound
#

#Implementation considering the equations as in the original paper (2n variables and n equations) using the Buchberger algorithm
def tester_buch_normal_system(n):
     #Creation of some useful vector
     canonical_vector=[[] for i in range(n)]
     for i in range(n):
          for j in range(n):
               canonical_vector[i].append(1 if i==j else 0)
     uno = [1 for i in range(n)]
     cero = [0 for i in range(n)]

     #Creation of variables
     X = [symbols('x%d' % i) for i in range(n)]
     Y = [symbols('y%d' % i) for i in range(n)]
     Variables = X+Y
     init_printing(use_unicode=False, wrap_line=False)

     #Creation of the n equations
     equations=[]
     for i in range(n-1):
          equations.append(inner_prod(X,left_shift_n(X,i+1)))
     equations.append(X[0])
     Y.reverse()
     equations=substraction(equations,Y)

     #SOL=Groebner basis
     SOL=groebner(equations, Variables, domain='ZZ', order='lex')

     #SOL_at_X_0=Groebner basis evaluated at X=0
     SOL_at_X_0=[]
     for i in range(len(SOL)):
          SOL_at_X_0.append(substitution(SOL[i],X,cero))

     #LMSOL=set of leading monomials of the polynomials in the groebner basis
     LMSOL=[]
     for i in range(len(SOL)):
          LMSOL.append(polys.polytools.LM(SOL[i], order="lex"))

     #LMSOL_at_Y_1=set of leading monomials evaluated at Y=(1,1,...,1)
     #These monomials are used to find the leading monomials of the form x_i^k for some k avoiding the appearence of Y terms.
     LMSOL_at_Y_1=[]
     for i in range(len(LMSOL)):
          LMSOL_at_Y_1.append(substitution(LMSOL[i],Y,uno))

     #Groebner test-----------------------------------------------------------------------------------------------------

     Groebner_indexes=[]
     Groebner_tester=0
     for i in range(n):
          temp_list=[]
          for j in range(len(LMSOL_at_Y_1)):
               #By evaluating at X=e_j and comparing it to 1 we find the leading monomials of the form x_i^k for some k
               if substitution(LMSOL_at_Y_1[j],X,canonical_vector[i])==1:
                    temp_list.append(j)
          if len(temp_list)!=0:
               Groebner_indexes.append(temp_list[0])
               Groebner_tester=Groebner_tester+1
          else:
               Groebner_indexes.append("")
     #Groebner conclusion:
     #If Groebner_teste=n we get that every indeterminate appear in the leading monomials of the Groebner basis and then, if there is at least one solution, there is a finite amount of them. In other case, if there is at least one solution, there is an infinite amount of them.
     #Aditionally, the list Groebner_indexes is created and its ith term is the number of the first equation in the Groebner basis such that its leeading monomial is of the form x_i^k for some k>0


     #Hilbert test------------------------------------------------------------------------------------------------------
     Hilbert_tester=0
     problem_indexes=[]
     for i in range(len(SOL_at_X_0)):
          if SOL_at_X_0[i]==SOL[i]:
               Hilbert_tester=Hilbert_tester+1
               problem_indexes.append(i)
     #Hilbert conclusion:
     #If after this process Hilbert_tester>0, we have found some equations without X terms and hence with only Y terms. If this equations are not 0, 1 is in the ideal generated by the Groebner Basis and by the Hilbert test the system does not have any solution.

     #Conclusion--------------------------------------------------------------------------------------------------------
     log_existence="About the existence of solutions:\n\n"
     if Hilbert_tester>0:
          log_existence+="The system does not have any solution unless the following equations are satisfied:\n"
          for i in range(len(problem_indexes)):
               log_existence+=str(SOL_at_X_0[problem_indexes[i]])+"=0\n"
     else:
          log_existence+="There is at least one solution since 1 is not in the ideal generated by the Groebner basis.\n"

     log_number_solutions="About the number of solutions:\n\n"
     if Groebner_tester==n:
          log_number_solutions+="If there is at least one solution, and y_j is not 0 for all j, then there is a finite amount of these since the following polynomials can be found in the Groebner basis:\n"
          for i in range(len(Groebner_indexes)):
               log_number_solutions+=str(SOL[Groebner_indexes[i]])+"\n"
     else:
          log_number_solutions+="If there is at least one solution, and y_j is not 0 for all j, then there is an infinite amount of these, since not all indeterminate appear as leading monomials."

     log_groebner_basis="Groebner basis:\n\n"
     for i in range(len(SOL)):
          log_groebner_basis+=str(SOL[i])+"\n"

     log_equations = "Equations:\n\n"
     for i in range(len(equations)):
          log_equations += str(equations[i]) + "\n"

     log=log_existence+ "\n\n" +log_number_solutions+ "\n\n" + log_equations

     log_file = open("Test for "+str(n)+" equations (tester_buch_normal_system).txt", "w")
     log_file.write(log)
     log_file.close()

     groebner_basis_file = open("Groebner Basis for " + str(n) + " equations.txt", "w")
     groebner_basis_file.write(log_groebner_basis)
     groebner_basis_file.close()
     return

#Implementation considering the equations as in the original paper without x_0, y_0 and x_1 since these can be solved by hand (2n-3 variables and n-2 equations) using the Buchberger algorithm
def tester_buch_simpler_system(n):
     # Creation of some useful vector
     canonical_vector = [[] for i in range(n)]
     for i in range(n):
          for j in range(n):
               canonical_vector[i].append(1 if i == j else 0)
     uno = [1 for i in range(n)]
     cero = [0 for i in range(n)]

     # Creation of variables
     X = [symbols('x%d' % i) for i in range(n)]
     Y = [symbols('y%d' % i) for i in range(n)]
     Variables = X + Y
     init_printing(use_unicode=False, wrap_line=False)

     # Creation of the n equations
     equations = []
     for i in range(n - 1):
          equations.append(inner_prod(X, left_shift_n(X, i + 1)))
     equations.append(X[0])
     Y.reverse()
     equations = substraction(equations, Y)
     Y.reverse()
     safe_equations=equations

     #Fixing x_0=y_0=1 and x_n-1=y_1
     #Also, removing the last two equations (x_0=y_0 and x_0*x_{n-1}=y_1)
     base_variables=[X[0],Y[0],X[n-1]]
     base_substitutions=[1,1,Y[1]]
     for i in range(len(equations)-2):
          equations[i]=substitution(equations[i],base_variables,base_substitutions)
     equations=equations[0:len(equations)-2]
     #Conclusion:
     #Fixing x_0,y_0 and x_n removes the number of variables in 3 and the number of equations in 2

     # SOL=Groebner basis
     SOL = groebner(equations, Variables, domain='ZZ', order='lex')

     # SOL_at_X_0=Groebner basis evaluated at X=0
     SOL_at_X_0 = []
     for i in range(len(SOL)):
          SOL_at_X_0.append(substitution(SOL[i], X, cero))

     # LMSOL=set of leading monomials of the polynomials in the groebner basis
     LMSOL = []
     for i in range(len(SOL)):
          LMSOL.append(polys.polytools.LM(SOL[i], order="lex"))

     # LMSOL_at_Y_1=set of leading monomials evaluated at Y=(1,1,...,1)
     # These monomials are used to find the leading monomials of the form x_i^k for some k avoiding the appearence of Y terms.
     LMSOL_at_Y_1 = []
     for i in range(len(LMSOL)):
          LMSOL_at_Y_1.append(substitution(LMSOL[i], Y, uno))

     # Groebner test-----------------------------------------------------------------------------------------------------

     Groebner_indexes = []
     Groebner_tester = 0
     for i in range(1,n):
          temp_list = []
          for j in range(len(LMSOL_at_Y_1)):
               # By evaluating at X=e_j and comparing it to 1 we find the leading monomials of the form x_i^k for some k
               if substitution(LMSOL_at_Y_1[j], X, canonical_vector[i]) == 1:
                    temp_list.append(j)
          if len(temp_list) != 0:
               Groebner_indexes.append(temp_list[0])
               Groebner_tester = Groebner_tester + 1
     # Groebner conclusion:
     # If Groebner_test=n-2 we get that every indeterminate appear in the leading monomials of the Groebner basis and then, if there is at least one solution, there is a finite amount of them. In other case, if there is at least one solution, there is an infinite amount of them.
     # Aditionally, the list Groebner_indexes is created and its ith term is the number of the first equation in the Groebner basis such that its leeading monomial is of the form x_i^k for some k>0

     # Hilbert test------------------------------------------------------------------------------------------------------
     Hilbert_tester = 0
     problem_indexes = []
     for i in range(len(SOL_at_X_0)):
          if SOL_at_X_0[i] == SOL[i]:
               Hilbert_tester = Hilbert_tester + 1
               problem_indexes.append(i)
     # Hilbert conclusion:
     # If after this process Hilbert_tester>0, we have found some equations without X terms and hence with only Y terms. If this equations are not 0, 1 is in the ideal generated by the Groebner Basis and by the Hilbert test the system does not have any solution.

     # Conclusion--------------------------------------------------------------------------------------------------------
     log_existence = "About the existence of solutions:\n\n"
     if Hilbert_tester > 0:
          log_existence += "The system does not have any solution unless the following equations are satisfied:\n"
          for i in range(len(problem_indexes)):
               log_existence += str(SOL_at_X_0[problem_indexes[i]]) + "=0\n"
     else:
          log_existence += "There is at least one solution since 1 is not in the ideal generated by the Groebner basis.\n"

     log_number_solutions = "About the number of solutions:\n\n"
     if Groebner_tester == n-2:
          log_number_solutions += "If there is at least one solution, and y_j is not 0 for all j, then there is a finite amount of these since the following polynomials can be found in the Groebner basis:\n"
          for i in range(len(Groebner_indexes)):
               log_number_solutions += str(SOL[Groebner_indexes[i]]) + "\n"
     else:
          log_number_solutions += "If there is at least one solution, and y_j is not 0 for all j, then there is an infinite amount of these, since not all indeterminate appear as leading monomials.\n"

     log_groebner_basis = "Groebner basis:\n\n"
     for i in range(len(SOL)):
          log_groebner_basis += str(SOL[i]) + "\n"

     log_equations = "Equations:\n\n"
     for i in range(len(equations)):
          log_equations += str(equations[i]) + "\n"

     log=log_existence+"\n\n"+log_number_solutions+ "\n\n" + log_equations

     log_file = open("Test for "+str(n)+" equations (tester_buch_simpler_system).txt", "w")
     log_file.write(log)
     log_file.close()

     groebner_basis_file = open("Groebner Basis for " + str(n) + " equations.txt", "w")
     groebner_basis_file.write(log_groebner_basis)
     groebner_basis_file.close()
     return

#Implementation considering the equations as in the original paper without x_0, y_0 and x_1 since these can be solved by hand (2n-3 variables and n-2 equations) using the F5 algorithm
def tester_F5_homo_system(n):
     #CCreation of some useful vector
     canonical_vector=[[] for i in range(n)]
     for i in range(n):
          for j in range(n):
               canonical_vector[i].append(1 if i==j else 0)
     uno = [1 for i in range(n)]
     cero = [0 for i in range(n)]

     #Creation of variables
     X = [symbols('x%d' % i) for i in range(n)]
     Y = [symbols('y%d' % i) for i in range(n)]
     Variables = X+Y
     init_printing(use_unicode=False, wrap_line=False)

     #Creation of the n equations
     equations=[]
     for i in range(n-1):
          equations.append(inner_prod(X,left_shift_n(X,i+1)))
     equations.append(X[0]**2)
     Y.reverse()
     Y_squared=[Y[i]**2 for i in range(n)]
     equations=substraction(equations,Y_squared)

     #SOL=Groebner basis
     SOL=groebner(equations, Variables, domain='ZZ', order='lex',method="f5b")

     #SOL_at_X_0=Groebner basis evaluated at X=0
     SOL_at_X_0=[]
     for i in range(len(SOL)):
          SOL_at_X_0.append(substitution(SOL[i],X,cero))

     #LMSOL=set of leading monomials of the polynomials in the groebner basis
     LMSOL=[]
     for i in range(len(SOL)):
          LMSOL.append(polys.polytools.LM(SOL[i], order="lex"))

     #LMSOL_at_Y_1=set of leading monomials evaluated at Y=(1,1,...,1)
     #These monomials are used to find the leading monomials of the form x_i^k for some k avoiding the appearence of Y terms.
     LMSOL_at_Y_1=[]
     for i in range(len(LMSOL)):
          LMSOL_at_Y_1.append(substitution(LMSOL[i],Y,uno))

     #Groebner test-----------------------------------------------------------------------------------------------------

     Groebner_indexes=[]
     Groebner_tester=0
     for i in range(n):
          temp_list=[]
          for j in range(len(LMSOL_at_Y_1)):
               #By evaluating at X=e_j and comparing it to 1 we find the leading monomials of the form x_i^k for some k
               if substitution(LMSOL_at_Y_1[j],X,canonical_vector[i])==1:
                    temp_list.append(j)
          if len(temp_list)!=0:
               Groebner_indexes.append(temp_list[0])
               Groebner_tester=Groebner_tester+1
          else:
               Groebner_indexes.append("")
     #Groebner conclusion:
     #If Groebner_teste=n we get that every indeterminate appear in the leading monomials of the Groebner basis and then, if there is at least one solution, there is a finite amount of them. In other case, if there is at least one solution, there is an infinite amount of them.
     #Aditionally, the list Groebner_indexes is created and its ith term is the number of the first equation in the Groebner basis such that its leeading monomial is of the form x_i^k for some k>0


     #Hilbert test------------------------------------------------------------------------------------------------------
     Hilbert_tester=0
     problem_indexes=[]
     for i in range(len(SOL_at_X_0)):
          if SOL_at_X_0[i]==SOL[i]:
               Hilbert_tester=Hilbert_tester+1
               problem_indexes.append(i)
     #Hilbert conclusion:
     #If after this process Hilbert_tester>0, we have found some equations without X terms and hence with only Y terms. If this equations are not 0, 1 is in the ideal generated by the Groebner Basis and by the Hilbert test the system does not have any solution.

     #Conclusion--------------------------------------------------------------------------------------------------------
     log_existence="About the existence of solutions:\n\n"
     if Hilbert_tester>0:
          log_existence+="The system does not have any solution unless the following equations are satisfied:\n"
          for i in range(len(problem_indexes)):
               log_existence+=str(SOL_at_X_0[problem_indexes[i]])+"=0\n"
     else:
          log_existence+="There is at least one solution since 1 is not in the ideal generated by the Groebner basis.\n"

     log_number_solutions="About the number of solutions:\n\n"
     if Groebner_tester==n:
          log_number_solutions+="If there is at least one solution, and y_j is not 0 for all j, then there is a finite amount of these since the following polynomials can be found in the Groebner basis:\n"
          for i in range(len(Groebner_indexes)):
               log_number_solutions+=str(SOL[Groebner_indexes[i]])+"\n"
     else:
          log_number_solutions+="If there is at least one solution, and y_j is not 0 for all j, then there is an infinite amount of these, since not all indeterminate appear as leading monomials.\n"

     log_groebner_basis="Groebner basis:\n\n"
     for i in range(len(SOL)):
          log_groebner_basis+=str(SOL[i])+"\n"

     log_equations = "Equations:\n\n"
     for i in range(len(equations)):
          log_equations += str(equations[i]) + "\n"

     log=log_existence+"\n\n"+log_number_solutions+ "\n\n" + log_equations

     log_file = open("Test for "+str(n)+" equations (tester_F5_homo_system).txt", "w")
     log_file.write(log)
     log_file.close()

     groebner_basis_file = open("Groebner Basis for " + str(n) + " equations.txt", "w")
     groebner_basis_file.write(log_groebner_basis)
     groebner_basis_file.close()
     return

#Implementation considering the original equations changing Y_j to y_j**2 for j>0 and squaring the first equation to make the system homogeneous, using the F5 algorithm
def tester_F5_simpler_system(n):
     # Creation of some useful vector
     canonical_vector = [[] for i in range(n)]
     for i in range(n):
          for j in range(n):
               canonical_vector[i].append(1 if i == j else 0)
     uno = [1 for i in range(n)]
     cero = [0 for i in range(n)]

     # Creation of variables
     X = [symbols('x%d' % i) for i in range(n)]
     Y = [symbols('y%d' % i) for i in range(n)]
     Variables = X + Y
     init_printing(use_unicode=False, wrap_line=False)

     #Creation of the n equations
     equations = []
     for i in range(n - 1):
          equations.append(inner_prod(X, left_shift_n(X, i + 1)))
     equations.append(X[0])
     Y.reverse()
     equations = substraction(equations, Y)
     Y.reverse()
     safe_equations=equations

     #Fixing x_0=y_0=1 and x_n-1=y_1
     #Also, removing the last two equations (x_0=y_0 and x_0*x_{n-1}=y_1)
     base_variables=[X[0],Y[0],X[n-1]]
     base_substitutions=[1,1,Y[1]]
     for i in range(len(equations)-2):
          equations[i]=substitution(equations[i],base_variables,base_substitutions)
     equations=equations[0:len(equations)-2]
     #Conclusion:
     #Fixing x_0,y_0 and x_n removes the number of variables in 3 and the number of equations in 2

     # SOL=Groebner basis
     SOL = groebner(equations, Variables, domain='ZZ', order='lex', method="f5b")

     # SOL_at_X_0=Groebner basis evaluated at X=0
     SOL_at_X_0 = []
     for i in range(len(SOL)):
          SOL_at_X_0.append(substitution(SOL[i], X, cero))

     # LMSOL=set of leading monomials of the polynomials in the groebner basis
     LMSOL = []
     for i in range(len(SOL)):
          LMSOL.append(polys.polytools.LM(SOL[i], order="lex"))

     # LMSOL_at_Y_1=set of leading monomials evaluated at Y=(1,1,...,1)
     # These monomials are used to find the leading monomials of the form x_i^k for some k avoiding the appearence of Y terms.
     LMSOL_at_Y_1 = []
     for i in range(len(LMSOL)):
          LMSOL_at_Y_1.append(substitution(LMSOL[i], Y, uno))

     # Groebner test-----------------------------------------------------------------------------------------------------

     Groebner_indexes = []
     Groebner_tester = 0
     for i in range(1,n):
          temp_list = []
          for j in range(len(LMSOL_at_Y_1)):
               # By evaluating at X=e_j and comparing it to 1 we find the leading monomials of the form x_i^k for some k
               if substitution(LMSOL_at_Y_1[j], X, canonical_vector[i]) == 1:
                    temp_list.append(j)
          if len(temp_list) != 0:
               Groebner_indexes.append(temp_list[0])
               Groebner_tester = Groebner_tester + 1
     # Groebner conclusion:
     # If Groebner_teste=n we get that every indeterminate appear in the leading monomials of the Groebner basis and then, if there is at least one solution, there is a finite amount of them. In other case, if there is at least one solution, there is an infinite amount of them.
     # Aditionally, the list Groebner_indexes is created and its ith term is the number of the first equation in the Groebner basis such that its leeading monomial is of the form x_i^k for some k>0

     # Hilbert test------------------------------------------------------------------------------------------------------
     Hilbert_tester = 0
     problem_indexes = []
     for i in range(len(SOL_at_X_0)):
          if SOL_at_X_0[i] == SOL[i]:
               Hilbert_tester = Hilbert_tester + 1
               problem_indexes.append(i)
     # Hilbert conclusion:
     # If after this process Hilbert_tester>0, we have found some equations without X terms and hence with only Y terms. If this equations are not 0, 1 is in the ideal generated by the Groebner Basis and by the Hilbert test the system does not have any solution.

     # Conclusion--------------------------------------------------------------------------------------------------------
     log_existence = "About the existence of solutions:\n\n"
     if Hilbert_tester > 0:
          log_existence += "The system does not have any solution unless the following equations are satisfied:\n"
          for i in range(len(problem_indexes)):
               log_existence += str(SOL_at_X_0[problem_indexes[i]]) + "=0\n"
     else:
          log_existence += "There is at least one solution since 1 is not in the ideal generated by the Groebner basis.\n"

     log_number_solutions = "About the number of solutions:\n\n"
     if Groebner_tester == n-2:
          log_number_solutions += "If there is at least one solution, and y_j is not 0 for all j, then there is a finite amount of these since the following polynomials can be found in the Groebner basis:\n"
          for i in range(len(Groebner_indexes)):
               log_number_solutions += str(SOL[Groebner_indexes[i]]) + "\n"
     else:
          log_number_solutions += "If there is at least one solution, and y_j is not 0 for all j, then there is an infinite amount of these, since not all indeterminate appear as leading monomials.\n"

     log_groebner_basis = "Groebner basis:\n\n"
     for i in range(len(SOL)):
          log_groebner_basis += str(SOL[i]) + "\n"

     log_equations = "Equations:\n\n"
     for i in range(len(equations)):
          log_equations += str(equations[i]) + "\n"

     log=log_existence+ "\n\n" +log_number_solutions+ "\n\n" + log_equations

     log_file = open("Test for "+str(n)+" equations (tester_F5_simpler_system).txt", "w")
     log_file.write(log)
     log_file.close()

     groebner_basis_file = open("Groebner Basis for " + str(n) + " equations.txt", "w")
     groebner_basis_file.write(log_groebner_basis)
     groebner_basis_file.close()
     return



